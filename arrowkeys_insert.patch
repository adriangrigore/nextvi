diff --git a/led.c b/led.c
index 3a43e64..99c3e1b 100644
--- a/led.c
+++ b/led.c
@@ -288,7 +288,7 @@ static int led_lastword(char *s)
 	return r - s;
 }
 
-static void led_printparts(char *ai, char *pref, char *main, char *post)
+static void led_printparts(char *ai, char *pref, char *main, char *post, int print)
 {
 	if (!xled)
 		return;
@@ -309,8 +309,10 @@ static void led_printparts(char *ai, char *pref, char *main, char *post)
 		xleft = pos - xcols / 2;
 	if (pos < xleft)
 		xleft = pos < xcols ? 0 : pos - xcols / 2;
-	syn_blockhl = 0;
-	led_print(ln->s, -1);
+	if (print) {
+		syn_blockhl = 0;
+		led_print(ln->s, -1);
+	}
 	/* cursor position for inserting the next character */
 	if (*pref || *main || *ai) {
 		if (off - 2 >= 0)
@@ -387,7 +389,8 @@ static char *led_line(char *pref, char *post, char *ai,
 	if (!post)
 		post = "";
 	while (1) {
-		led_printparts(ai, pref, sb->s, post);
+		led_printparts(ai, pref, sb->s, post, !memchr("ABCD", vi_insmov, 4));
+		vi_insmov = -1;
 		len = sb->s_n;
 		c = term_read();
 		switch (c) {
@@ -571,6 +574,20 @@ static char *led_line(char *pref, char *post, char *ai,
 		case TK_CTL('l'):
 			term_clean();
 			continue;
+		case '\033':;	/* Arrow keys */
+			char cbuf[1];
+			cbuf[0] = '\0';
+			int fl = fcntl(STDIN_FILENO, F_GETFL);
+			fcntl(STDIN_FILENO, F_SETFL, fl | O_NONBLOCK);
+			read(STDIN_FILENO, cbuf, 1);
+			if (*cbuf == '[') {
+				read(STDIN_FILENO, cbuf, 1);
+				vi_insmov = *cbuf;
+				fcntl(STDIN_FILENO, F_SETFL, fl);
+				goto _leave;
+			}
+			fcntl(STDIN_FILENO, F_SETFL, fl);
+			goto leave;
 		case TK_CTL('o'):;
 			preserve(int, xvis, 0)
 			term_exec(":", 1, /*nop*/, /*nop*/)
@@ -588,6 +605,7 @@ static char *led_line(char *pref, char *post, char *ai,
 	}
 leave:
 	vi_insmov = c;
+_leave:
 	*key = c;
 	sbufn_done(sb)
 }
@@ -648,7 +666,7 @@ sbuf *led_input(char *pref, char *post, int *kmap, int row)
 			return sb;
 		}
 		led_printparts(ai, pref ? pref : "", uc_lastline(ln),
-				key == '\n' ? "" : post);
+				key == '\n' ? "" : post, 1);
 		if (key == '\n')
 			term_chr('\n');
 		if (!pref || !pref[0]) {	/* updating autoindent */
diff --git a/vi.c b/vi.c
index dd93822..f94e8e5 100644
--- a/vi.c
+++ b/vi.c
@@ -1002,10 +1002,13 @@ static int charcount(char *text, int tlen, char *post)
 	return uc_slen(nl) - uc_slen(post);
 }
 
+static int lmodified;
+
 static char *vi_input(char *pref, char *post, int row)
 {
 	sbuf *rep = led_input(pref, post, &xkmap, row);
 	xoff = *rep->s ? charcount(rep->s, rep->s_n, post) : xoff;
+	lmodified = *rep->s;
 	sbufn_done(rep)
 }
 
@@ -1730,6 +1733,37 @@ void vi(int init)
 				vc_insert(c);
 				vi_mod = !xpac && xrow == orow ? 3 : 1;
 				ins:
+				switch (vi_insmov) {
+				case 'A':	/* ↑ */
+					vi_back(!lmodified ? c : 'i');
+					if (lmodified)
+						vi_col = vi_off2col(xb, xrow, xoff);
+					xrow--;
+					xrow = xrow < 0 ? 0 : xrow;
+					xoff = vi_col2off(xb, xrow, vi_col);
+					lmodified = 0;
+					goto _break;
+				case 'B':	/* ↓ */
+					vi_back(!lmodified ? c : 'i');
+					if (lmodified)
+						vi_col = vi_off2col(xb, xrow, xoff);
+					xrow++;
+					xoff = vi_col2off(xb, xrow, vi_col);
+					lmodified = 0;
+					goto _break;
+				case 'D':	/* ← */
+					vi_back('i');
+					xoff--;
+					xoff = xoff < 0 ? 0 : xoff;
+					vi_col = vi_off2col(xb, xrow, xoff);
+					goto _break;
+				case 'C':	/* → */
+					vi_back(*uc_chr(lbuf_get(xb, xrow), xoff+2) ? 'i' : 'A');
+					xoff++;
+					if (*uc_chr(lbuf_get(xb, xrow), xoff))
+						vi_col = vi_off2col(xb, xrow, xoff);
+					goto _break;
+				}
 				if (vi_insmov == 127) {
 					vi_mod = vi_mod == 3 ? 2 : 1;
 					if (xrow && !(xoff > 0 && lbuf_eol(xb, xrow))) {
@@ -1744,6 +1778,9 @@ void vi(int init)
 					xoff--;
 				xoff = xoff < 0 ? 0 : xoff;
 				break;
+				_break:
+				vi_mod = 0;
+				break;
 			case 'J':
 				vc_join(vi_joinmode, vi_arg1 <= 1 ? 2 : vi_arg1);
 				break;
