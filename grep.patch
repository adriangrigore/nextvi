diff --git a/conf.c b/conf.c
index 4d2b8a5..ee9b4c3 100644
--- a/conf.c
+++ b/conf.c
@@ -228,6 +228,11 @@ strike|tt|xmp|doctype|h1|h2|h3|h4|h5|h6|\
 		{0, SYN_BGMK(9), SYN_BGMK(8), SYN_BGMK(7)}},
 	{"/ac", "[^ \t-/:-@[-^{-~]+$|(.+$)", {0, SYN_BGMK(8)}},
 
+	/* grep buffer */
+	/* I don't feel like making new ->func index so reuse 3 here */
+	{"/grep", "^(.+?):([0-9]+):(.+)", {5, 10, 6, 8}, {1, 0, 0, 1}},
+	{"/grep", NULL, {7 | SYN_BGMK(9)}, {0}, 0, 3},
+
 	/* status bar (is never '\n' terminated) */
 	{"/-", "^(\".*\").*(\\[[wr]\\]).*$", {8 | SYN_BD, 4, 1}},
 	{"/-", "^(\".*\").* ([0-9]{1,3}%) (L[0-9]+) (C[0-9]+) (B[0-9]+)?.*$",
diff --git a/ex.c b/ex.c
index b5ab1da..c5764cb 100644
--- a/ex.c
+++ b/ex.c
@@ -32,7 +32,7 @@ static rset *xkwdrs;		/* the last searched keyword rset */
 static char xrep[EXLEN];	/* the last replacement */
 static int xkwddir;		/* the last search direction */
 static int xgdep;		/* global command recursion depth */
-static struct buf tempbufs[2];	/* temporary buffers, for internal use */
+static struct buf tempbufs[3];	/* temporary buffers, for internal use */
 
 static int bufs_find(const char *path)
 {
diff --git a/vi.c b/vi.c
index 7c93487..e8e2721 100644
--- a/vi.c
+++ b/vi.c
@@ -661,8 +661,8 @@ void dir_calc(char *cur_dir)
 	closedir(dp);
 }
 
-#define fssearch() \
-if (ex_edit(path) && xrow) { \
+#define fssearch(isbuffer) \
+if (isbuffer) { \
 	*row = xrow; *off = xoff-1; /* short circuit */ \
 	if (!vi_search('n', cnt, row, off, 0)) \
 		return 1; \
@@ -673,15 +673,14 @@ if (ex_edit(path) && xrow) { \
 if (!vi_search(*row ? 'N' : 'n', cnt, row, off, 0)) \
 	return 1; \
 
-static int fs_search(int cnt, int *row, int *off)
+static int fs_search(int again, int cnt, int *row, int *off)
 {
 	char *path;
-	int again = 0;
 	redo:
 	while (fspos < fstlen) {
 		path = &fslink[fspos+sizeof(int)];
 		fspos += *(int*)((char*)fslink+fspos) + sizeof(int);
-		fssearch()
+		fssearch(ex_edit(path) && xrow && again != 2)
 	}
 	if (fspos == fstlen && !again) {
 		fspos = 0;
@@ -705,7 +704,7 @@ static int fs_searchback(int cnt, int *row, int *off)
 	for (int i = count; i < fscount; i++) {
 		path = paths[i];
 		fspos -= *(int*)((char*)path-sizeof(int))+sizeof(int);
-		fssearch()
+		fssearch(ex_edit(path) && xrow)
 	}
 	return 0;
 }
@@ -808,6 +807,7 @@ static int vi_motion(int *row, int *off)
 				break;
 		break;
 	case TK_CTL(']'):	/* note: this is also ^5 as per ascii */
+	case TK_CTL('x'):
 	case TK_CTL('p'):
 		if (!fslink)
 			mdir_calc(fs_exdir ? fs_exdir : ".")
@@ -815,14 +815,55 @@ static int vi_motion(int *row, int *off)
 			ex_krsset(cs, +1);
 			free(cs);
 		}
-		if (lkwdcnt != xkwdcnt && ex_buf != &bufs[xbufcur-1])
-			ex_pbuf = ex_buf;	/* check if keyword changed */
-		lkwdcnt = xkwdcnt;
+		if (mv != TK_CTL('x')) {
+			if (lkwdcnt != xkwdcnt && ex_buf != &bufs[xbufcur-1])
+				ex_pbuf = ex_buf;
+			lkwdcnt = xkwdcnt;
+		}
 		{
 			preserve(struct buf*, ex_pbuf, ex_pbuf)
 			if (mv == TK_CTL(']'))
-				fs_search(1, row, off);
-			else if (!fs_searchback(1, row, off)) {
+				fs_search(0, 1, row, off);
+			else if (mv == TK_CTL('x')) {
+				if (!strcmp(ex_path, "/grep/"))
+					return -1;
+				temp_done(2);
+				term_exec("qq", 3, /*nop*/, /*nop*/)
+				temp_open(2, "/grep/", "/grep");
+				sbuf *gstats; sbuf_make(gstats, 1024)
+				char nbuf[100];
+				int colpos = 0;
+				fspos = 0;
+				while (fs_search(2, 1, row, off)) {
+					sbuf_str(gstats, ex_path)
+					sbuf_chr(gstats, ':')
+					colpos = gstats->s_n;
+					#define nextrow() \
+					itoa((*row)+1, nbuf); \
+					sbuf_str(gstats, nbuf) \
+					sbuf_chr(gstats, ':') \
+					sbufn_str(gstats, lbuf_get(xb, *row)) \
+					temp_write(2, gstats->s); \
+					(*row)++; \
+	
+					nextrow()
+					while (!vi_search('n', cnt, row, off, 0)) {
+						sbuf_cut(gstats, colpos)
+						nextrow()
+					}
+					sbuf_cut(gstats, 0)
+				}
+				for (i = xbufcur-1; i >= 0 && bufs[i].mtime == -1; i--)
+					ex_bufpostfix(i, 1);
+				temp_switch(2);
+				syn_addhl(regs['/'], 3, 1); /* see conf.c */
+				syn_reloadft();
+				vi(1);
+				temp_switch(2);
+				*row = srow; *off = soff;
+				ex_edit(savepath->s);
+				xquit = 0;
+			} else if (!fs_searchback(1, row, off)) {
 				if (savepath) {
 					open_saved:
 					*row = srow; *off = soff;
@@ -1549,7 +1590,19 @@ void vi(int init)
 				buf[1] = 'e';
 				buf[2] = ' ';
 				strcpy(buf+3, ln);
-				term_push(buf, strlen(ln)+3);
+				cs = NULL;
+				if (!strcmp(ex_path, "/grep/")) {
+					int subs[2];
+					rset *rs = rset_make(1, (char*[]){":[0-9]+:"}, 0);
+					if (rset_find(rs, buf, 1, subs, 0) >= 0) {
+						buf[subs[0]] = '|';
+						buf[subs[1]-1] = '\n';
+						buf[subs[1]] = '\0';
+					}
+					rset_free(rs);
+					xquit = 1;
+				}
+				term_push(buf, strlen(buf));
 				if (!strcmp(ex_path, "/fm/"))
 					xquit = 1;
 				vi_mod = 1;
@@ -1695,6 +1748,14 @@ void vi(int init)
 					}
 					ln = vi_prompt(":", buf, &kmap);
 					goto do_excmd; }
+				case 'x':
+					temp_open(2, "/grep/", "/grep");
+					temp_sswitch(2)
+					vi(1);
+					temp_pswitch(2)
+					xquit = 0;
+					vi_mod = 1;
+					break;
 				default:
 					vi_back(k);
 				}
