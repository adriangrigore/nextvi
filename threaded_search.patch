diff --git a/build.sh b/build.sh
index 0fab531..832aec6 100755
--- a/build.sh
+++ b/build.sh
@@ -5,6 +5,7 @@ CFLAGS="\
 -Wno-missing-field-initializers \
 -Wno-unused-parameter \
 -Wfatal-errors -std=c99 \
+-lpthread \
 -D_POSIX_C_SOURCE=200809L $CFLAGS"
 
 OS="$(uname)"
diff --git a/lbuf.c b/lbuf.c
index 798be60..a47d6b7 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -419,35 +419,95 @@ int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *row, int *off)
 	return n != 0;
 }
 
-int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r, int *o, int *len)
+struct lsparams
+{
+	struct lbuf *lb;
+	rset *re;
+	int dir;
+	int ln_n;
+	int *r;
+	int *o;
+	int *len;
+};
+
+static void *lsearch(void *arg)
 {
-	int r0 = *r, o0 = *o, grp = xgrp;
+	struct lsparams *a = arg;
+	int r0 = *a->r, o0 = *a->o, grp = xgrp;
 	int offs[grp], i = r0;
-	char *s = lbuf_get(lb, i);
-	int off = dir > 0 && *uc_chr(s, o0 + 1) ? uc_chr(s, o0 + 1) - s : 0;
-	int ln_n = lbuf_len(lb);
-	for (; i >= 0 && i < ln_n; i += dir) {
-		s = lb->ln[i];
-		while (rset_find(re, s + off, grp / 2, offs,
+	char *s = lbuf_get(a->lb, i);
+	int off = a->dir > 0 && *uc_chr(s, o0 + 1) ? uc_chr(s, o0 + 1) - s : 0;
+	for (; i >= 0 && i < a->ln_n; i += a->dir) {
+		s = a->lb->ln[i];
+		while (rset_find(a->re, s + off, grp / 2, offs,
 				off ? REG_NOTBOL | REG_NEWLINE : REG_NEWLINE) >= 0) {
 			int g1 = offs[grp - 2], g2 = offs[grp - 1];
 			if (g1 < 0) {
 				off += offs[1] > 0 ? offs[1] : 1;
 				continue;
 			}
-			if (dir < 0 && r0 == i && uc_off(s, off+g1) >= o0)
+			if (a->dir < 0 && r0 == i && uc_off(s, off+g1) >= o0)
 				break;
-			*o = uc_off(s, off + g1);
-			*r = i;
-			*len = uc_off(s + off + g1, g2 - g1);
+			*a->o = uc_off(s, off + g1);
+			*a->r = i;
+			*a->len = uc_off(s + off + g1, g2 - g1);
 			off += g2 > 0 ? g2 : 1;
-			if (dir > 0)
-				return 0;
-			ln_n = -1; /* break outer loop efficiently */
+			a->ln_n = -1; /* break outer loop efficiently */
+			if (a->dir > 0)
+				return NULL;
 		}
 		off = 0;
 	}
-	return ln_n < 0 ? 0 : 1;
+	return NULL;
+}
+
+int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r, int *o, int *len)
+{
+	#define NUM_THREADS 4
+	pthread_t threads[NUM_THREADS];
+	static unsigned char fake_ulen[256]; /* novelty: for fast thread termination */
+	struct lsparams data[NUM_THREADS];
+	int rs[NUM_THREADS];
+	int os[NUM_THREADS];
+	int ls[NUM_THREADS];
+	int ln = lbuf_len(lb);
+	int thread_step = ln / NUM_THREADS; /* number of lines assigned per thread */
+	int step = 0, i = 0;
+	for (i = 0; i < NUM_THREADS; i++) {
+		if (*r + step > ln || *r + step * dir < 0)
+			break;
+		data[i].lb = lb;
+		data[i].re = re;
+		data[i].dir = dir;
+		rs[i] = *r + step * dir;
+		step += thread_step;
+		data[i].r = &rs[i];
+		if (i == NUM_THREADS-1)
+			data[i].ln_n = ln;
+		else
+			data[i].ln_n = MIN(rs[i] + thread_step, ln);
+		os[i] = i ? 0 : *o;
+		data[i].o = &os[i];
+		data[i].len = &ls[i];
+		pthread_create(&threads[i], NULL, lsearch, (void*) &data[i]);
+	}
+	for (step = i, i = 0; i < step; i++) {
+		pthread_join(threads[i], NULL);
+		if (data[i].ln_n < 0) {
+			*r = *data[i].r;
+			*o = *data[i].o;
+			*len = *data[i].len;
+			for (int z = i+1; z < step; z++)
+				data[z].ln_n = -1;
+			/* force instant termination, regardless how long string is */
+			utf8_length = fake_ulen;
+			for (int z = i+1; z < step; z++)
+				pthread_join(threads[z], NULL);
+			utf8_length = _utf8_length;
+			return 0;
+		}
+	}
+	return 1;
 }
 
 int lbuf_paragraphbeg(struct lbuf *lb, int dir, int *row, int *off)
diff --git a/uc.c b/uc.c
index 1ecaad1..5a06d08 100644
--- a/uc.c
+++ b/uc.c
@@ -1,4 +1,4 @@
-unsigned char utf8_length[256] = {
+unsigned char _utf8_length[256] = {
 	/*	0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F */
 	/* 0 */ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
 	/* 1 */ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
@@ -17,6 +17,7 @@ unsigned char utf8_length[256] = {
 	/* E */ 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
 	/* F */ 4, 4, 4, 4, 4, 4, 4, 4, 1, 1, 1, 1, 1, 1, 1, 1
 };
+unsigned char *utf8_length = _utf8_length;
 
 /* the number of utf-8 characters in s */
 int uc_slen(char *s)
diff --git a/vi.c b/vi.c
index 29c2524..98cfa86 100644
--- a/vi.c
+++ b/vi.c
@@ -31,6 +31,7 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #include <sys/wait.h>
+#include <pthread.h>
 #include "vi.h"
 #include "conf.c"
 #include "ex.c"
diff --git a/vi.h b/vi.h
index a246d1b..112268d 100644
--- a/vi.h
+++ b/vi.h
@@ -191,7 +191,8 @@ void syn_init(void);
 void syn_done(void);
 
 /* uc.c utf-8 helper functions */
-extern unsigned char utf8_length[256];
+extern unsigned char _utf8_length[256];
+extern unsigned char *utf8_length;
 /* return the length of a utf-8 character */
 #define uc_len(dst, s) dst = utf8_length[(unsigned char)s[0]];
 /* the unicode codepoint of the given utf-8 character */
