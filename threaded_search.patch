diff --git a/build.sh b/build.sh
index 0fab531..832aec6 100755
--- a/build.sh
+++ b/build.sh
@@ -5,6 +5,7 @@ CFLAGS="\
 -Wno-missing-field-initializers \
 -Wno-unused-parameter \
 -Wfatal-errors -std=c99 \
+-lpthread \
 -D_POSIX_C_SOURCE=200809L $CFLAGS"
 
 OS="$(uname)"
diff --git a/lbuf.c b/lbuf.c
index 798be60..e38778e 100644
--- a/lbuf.c
+++ b/lbuf.c
@@ -419,35 +419,96 @@ int lbuf_findchar(struct lbuf *lb, char *cs, int cmd, int n, int *row, int *off)
 	return n != 0;
 }
 
-int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r, int *o, int *len)
+struct lsparams
+{
+	struct lbuf *lb;
+	rset *re;
+	int dir;
+	int ln_n;
+	int *r;
+	int *o;
+	int *len;
+};
+
+static void *lsearch(void *arg)
 {
-	int r0 = *r, o0 = *o, grp = xgrp;
+	struct lsparams *a = arg;
+	int r0 = *a->r, o0 = *a->o, grp = xgrp;
 	int offs[grp], i = r0;
-	char *s = lbuf_get(lb, i);
-	int off = dir > 0 && *uc_chr(s, o0 + 1) ? uc_chr(s, o0 + 1) - s : 0;
-	int ln_n = lbuf_len(lb);
-	for (; i >= 0 && i < ln_n; i += dir) {
-		s = lb->ln[i];
-		while (rset_find(re, s + off, grp / 2, offs,
+	char *s = lbuf_get(a->lb, i);
+	int off = a->dir > 0 && *uc_chr(s, o0 + 1) ? uc_chr(s, o0 + 1) - s : 0;
+	for (; i >= 0 && i < a->ln_n; i += a->dir) {
+		s = a->lb->ln[i];
+		while (rset_find(a->re, s + off, grp / 2, offs,
 				off ? REG_NOTBOL | REG_NEWLINE : REG_NEWLINE) >= 0) {
 			int g1 = offs[grp - 2], g2 = offs[grp - 1];
 			if (g1 < 0) {
 				off += offs[1] > 0 ? offs[1] : 1;
 				continue;
 			}
-			if (dir < 0 && r0 == i && uc_off(s, off+g1) >= o0)
+			if (a->dir < 0 && r0 == i && uc_off(s, off+g1) >= o0)
 				break;
-			*o = uc_off(s, off + g1);
-			*r = i;
-			*len = uc_off(s + off + g1, g2 - g1);
+			*a->o = uc_off(s, off + g1);
+			*a->r = i;
+			*a->len = uc_off(s + off + g1, g2 - g1);
 			off += g2 > 0 ? g2 : 1;
-			if (dir > 0)
-				return 0;
-			ln_n = -1; /* break outer loop efficiently */
+			a->ln_n = -1; /* break outer loop efficiently */
+			if (a->dir > 0)
+				return NULL;
 		}
 		off = 0;
 	}
-	return ln_n < 0 ? 0 : 1;
+	return NULL;
+}
+
+int lbuf_search(struct lbuf *lb, rset *re, int dir, int *r, int *o, int *len)
+{
+	#define NUM_THREADS 4
+	pthread_t threads[NUM_THREADS];
+	struct lsparams data[NUM_THREADS];
+	int rs[NUM_THREADS];
+	int os[NUM_THREADS];
+	int ls[NUM_THREADS];
+	int ln = lbuf_len(lb);
+	int thread_step = ln / NUM_THREADS; /* number of lines assigned per thread */
+	int step = 0, i = 0;
+	int rval = dir > 0 ? ln + 1 : -1;
+	for (i = 0; i < NUM_THREADS; i++) {
+		if (*r + step > ln || *r + step * dir < 0)
+			break;
+		data[i].lb = lb;
+		data[i].re = re;
+		data[i].dir = dir;
+		rs[i] = *r + step * dir;
+		step += thread_step;
+		data[i].r = &rs[i];
+		if (i == NUM_THREADS-1)
+			data[i].ln_n = ln;
+		else
+			data[i].ln_n = MIN(rs[i] + thread_step, ln);
+		os[i] = i ? 0 : *o;
+		data[i].o = &os[i];
+		data[i].len = &ls[i];
+		pthread_create(&threads[i], NULL, lsearch, (void*) &data[i]);
+	}
+	for (i--, step = i; i >= 0; i--) {
+		pthread_join(threads[i], NULL);
+		if (data[i].ln_n < 0) {
+			if (dir > 0)
+				rval = MIN(rval, *data[i].r);
+			else
+				rval = MAX(rval, *data[i].r);
+		}
+	}
+	for (i = step; i >= 0; i--) {
+		if (data[i].ln_n < 0 && rval == *data[i].r) {
+			*r = rval;
+			*o = *data[i].o;
+			*len = *data[i].len;
+			return 0;
+		}
+	}
+	return 1;
 }
 
 int lbuf_paragraphbeg(struct lbuf *lb, int dir, int *row, int *off)
diff --git a/vi.c b/vi.c
index 29c2524..98cfa86 100644
--- a/vi.c
+++ b/vi.c
@@ -31,6 +31,7 @@
 #include <sys/stat.h>
 #include <sys/ioctl.h>
 #include <sys/wait.h>
+#include <pthread.h>
 #include "vi.h"
 #include "conf.c"
 #include "ex.c"
